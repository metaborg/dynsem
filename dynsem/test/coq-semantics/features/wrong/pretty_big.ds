module test/coq-semantics/langs/tricky_wrong
 
// What the specifier writes:  
signature

  sorts Expr constructors
     Int : Int -> Expr
   Float : Float -> Expr
    Plus : Expr * Expr -> Expr

  sorts Val constructors
     IntV : Int -> Val
   FloatV : Float -> Val
   WrongV : Val
  
  variables
    v : Val

  native operators
    plusI  : Int * Int -> Int
    plusF  : Float * Float -> Float

  arrows
    Expr --> Val

rules
  
  Plus(e1, e2) --> IntV(plusI(i1, i2))
  where
    e1 --> IntV(i1);
    e2 --> IntV(i2).
    
  Plus(e1, e2) --> FloatV(plusF(f1, f2))
  where
    e1 --> FloatV(f1);
    e2 --> FloatV(f2).



// Flag-based pretty-big-step with stuckness.
// This could be generated from the rules above:
signature

  sorts Term constructors
     IntT : Int -> Term
   FloatT : Float -> Term
    PlusT : Expr' * Expr' -> Term // Recursive occurrences of Expr get replaced

  sorts Expr' constructors
    T : Term -> Expr' {implicit}
    V : Val -> Expr' {implicit}
  
  arrows
    Expr' --> Expr'

  variables
    t : Term
  
  sorts F constructors
       OK : F
    STUCK : F

rules

  PlusT(t1, e2) :: F OK() --> x :: F f2
  where
    t1 :: F OK() --> x1 :: F f1;
    PlusT(x1, e2) :: F f1 --> x :: F f2.
  
  PlusT(IntV(i1), e2) :: F OK() --> x :: F f2
  where
    e2 :: F OK() --> x2 :: F f1;
    PlusT(IntV(i1), x2) :: F f1 --> x :: F f2.
    
  PlusT(FloatV(f1), e2) :: F OK() --> x :: F f2
  where
    e2 :: F OK() --> x2 :: F ff1;
    PlusT(FloatV(f1), x2) :: F ff1 --> x :: F f2.

  PlusT(IntV(i1), IntV(i2)) :: F OK() --> IntV(plusI(i1, i2)) :: F OK().

  PlusT(FloatV(f1), FloatV(f2)) :: F OK() --> FloatV(plusF(f1, f2)) :: F OK().
  
  // Lack of progress results in stuckness:
  e:Expr' :: F OK() --> e :: F STUCK()
  where
    e -progress-> false.
  
  // Stuckness preserves the structure of the stuck term:
  e:Expr' :: F STUCK() --> e :: F STUCK().
  
// Pretty-big-step progress judgment (inspired by Chargueraud's pretty-big-step progress judgment)
// This could be generated from the generated pretty-big-step rules above, by analyzing conclusion sources in rules.
signature
  
  arrows
    Expr' -progress-> Bool

rules

  PlusT(e1, e2) :: F OK() -progress-> b
  where
    case e1 of {
      T(_) =>
        e1 -progress-> b'; b' => b
      IntV(_) =>
        case e2 of {
          T(_) =>
            e2 -progress-> b'; b' => b
          IntV(_) =>
            true => b
          otherwise =>
            false => b
        }
      FloatV(_) =>
        case e2 of {
          T(_) =>
            e2 -progress-> b'; b' => b
          IntV(_) =>
            true => b
          otherwise =>
            false => b
        }
      otherwise =>
        false => b
    }.