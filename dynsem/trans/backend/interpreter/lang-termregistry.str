module backend/interpreter/lang-termregistry

imports
  signatures/-
  signatures/dynsem/-
  libjava-front
  backend/common/opts
  backend/interpreter/lang-ast
  backend/interpreter/names
  backend/interpreter/lists/registering
  backend/interpreter/tuples/registering
  backend/interpreter/nativeops/registering
  backend/interpreter/nativetypes/registering
  backend/utils/-
  analysis/-

rules /* term registry */

  ds-to-interp-terms-registry-top:
    mod@Module(_, section*) ->
      compilation-unit |[
        package ~x:<get-opt> TopPkg();
        
        import java.util.HashMap;
        import java.util.Map;
        
        import ~x:<get-opt> TermPkg().*;
        import ~x:<get-opt> BuildPkg().*;
        import ~x:<get-opt> MatchPkg().*;
        import ~x:<get-opt> ChecksPkg().*;
        import ~x:<get-opt> NativePkg().*;
        
        import org.metaborg.meta.lang.dynsem.interpreter.terms.ITerm;
        import org.spoofax.interpreter.terms.IStrategoTerm;
        import org.metaborg.meta.lang.dynsem.interpreter.ITermRegistry;
        import org.metaborg.meta.lang.dynsem.interpreter.nodes.building.*;
        import org.metaborg.meta.lang.dynsem.interpreter.nodes.matching.*;
        
        import com.oracle.truffle.api.CompilerAsserts;
        import com.oracle.truffle.api.source.SourceSection;
        
        public class x_classname implements ITermRegistry {
        
          private final Map<Class<?>, ITermBuildFactory> builderFactories = new HashMap<Class<?>, ITermBuildFactory>();
          private final Map<Class<?>, ITermMatchPatternFactory> matcherFactories = new HashMap<Class<?>, ITermMatchPatternFactory>();
          private final Map<Class<?>, ITermBuildFactory> nativeFactories = new HashMap<Class<?>, ITermBuildFactory>();
          private final Map<String, ITermBuildFactory> nativeAdapterFactories = new HashMap<String, ITermBuildFactory>();
          
          public x_classname() {
            init();
          }
        
          private void init() {
            bstm0*
            bstm1*
            bstm2*
            bstm3*
            bstm4*
          }
          
          @Override
          public ITerm parseProgramTerm(IStrategoTerm p) {
            return ~x:<jclass-term> SimpleSort(<get-opt> StartSymbol()).create(p);
          }
          
          @Override
          public ITermBuildFactory lookupBuildFactory(Class<?> termClass) {
            CompilerAsserts.neverPartOfCompilation();
            return builderFactories.get(termClass);
          }
        
          @Override
          public ITermMatchPatternFactory lookupMatchFactory(Class<?> termClass) {
            CompilerAsserts.neverPartOfCompilation();
            return matcherFactories.get(termClass);
          }
          
          @Override
          public ITermBuildFactory lookupNativeOpBuildFactory(Class<?> termClass) {
            CompilerAsserts.neverPartOfCompilation();
            return nativeFactories.get(termClass);
          }
          
          @Override
          public ITermBuildFactory lookupNativeTypeAdapterBuildFactory(String sort,
              String function, int arity) {
            CompilerAsserts.neverPartOfCompilation();
            return nativeAdapterFactories.get(sort + "/" + function + "/" + arity);
          }
          
          @Override
          public Class<?> getConstructorClass(String constr, int arity) {
            CompilerAsserts.neverPartOfCompilation();
            try {
              return x_classname.class.getClassLoader().loadClass(~e:Lit(String([Chars($[[<get-opt> TermPkg()].])])) + constr.replace("-", "_") + "_" + arity + "_Term");
            } catch (ClassNotFoundException cnfe) {
              throw new RuntimeException("Failed to load constructor class", cnfe);
            }
          }

          @Override
          public Class<?> getNativeOperatorClass(String constr, int arity) {
            CompilerAsserts.neverPartOfCompilation();
            try {
              return x_classname.class.getClassLoader().loadClass(~e:Lit(String([Chars($[[<get-opt> NativePkg()].])])) + constr.replace("-", "_") + "_" + arity);
            } catch (ClassNotFoundException cnfe) {
              throw new RuntimeException("Failed to load native operator class", cnfe);
            }
          }
  
          @Override
          public Class<?> getListClass(Class<?> elemClass) {
            CompilerAsserts.neverPartOfCompilation();
            try {
              return x_classname.class.getClassLoader().loadClass(~e:Lit(String([Chars($[[<get-opt> TermPkg()].List_])])) + elemClass.getName());
            } catch (ClassNotFoundException cnfe) {
              throw new RuntimeException("Failed to load constructor class", cnfe);
            }
          }

          @Override  
          public Class<?> getMapClass(String keySortName, String mapSortName) {
            throw new RuntimeException("Not implemented");
          }
          
      }
      ]|
    where
      debug(!"termreg1 ");
      <fetch-elem(?Signatures(sig*))> section*;
      debug(!"termreg2 ");
      decl* := <filter(?Constructors(<id>) + ?NativeOperators(<id>) + ?NativeDataTypes(<id>)); concat> sig*;
      debug(!"termreg3 ");
      (consdecl*, (natopdecl*, nattydecl*)) := <partition(?ConsDecl(_, _, _, _)); (id, partition(?NativeOpDecl(_, _, _, _)))> decl*;
      debug(!"termreg4 ");
      list-dec* := <get-languagelist-usage-in-signatures> sig*;
      debug(!"termreg5 ");
      tuple-dec* := <get-languagetuple-usage-in-module> mod;
      debug(!"termreg6 ");
      x_classname := $[[<get-opt> LangName()]TermRegistry]; 
      debug(!"termreg7 ");
      bstm0* := <ds-to-interp-terms-registry-inits> consdecl*;
      debug(!"termreg8 ");
      bstm1* := <ds-to-interp-natopterms-registry-inits> natopdecl*;
      debug(!"termreg9 ");
      bstm2* := <ds-to-interp-nattyterms-registry-inits> nattydecl*;
      debug(!"termreg10 ");
      bstm3* := <ds-to-interp-lists-registry-inits> list-dec*;
      debug(!"termreg11 ");
      bstm4* := <ds-to-interp-tuples-registry-inits> tuple-dec*
      ;debug(!"termreg12 ")

  ds-to-interp-terms-registry-inits = mapconcat(ds-to-interp-terms-registry-init)
  
  // FIXME extract
  ds-to-interp-terms-registry-init:
    dec@ConsDecl(name, kid*, _, _) ->
      bstm* |[
       builderFactories.put(x_conclass.class, new ITermBuildFactory() {
    
          @Override
          public x_termbuildclass apply(SourceSection source,
              TermBuild... children) {
            return x_termbuildNG.create(source, e1*);
          }
        });

        matcherFactories.put(x_conclass.class, new ITermMatchPatternFactory() {
    
          @Override
          public MatchPattern apply(SourceSection source,
              MatchPattern... children) {
            return x_matchNG.create(source, e2*);
          }
        });
      ]|
    with
      debug(!"reginit1 ");
      x_conclass := <jclass-term> dec;
      debug(!"reginit2 ");
      x_termbuildclass := <jclass-termbuilder> dec;
      debug(!"reginit3 ");
      x_termbuildNG := <jclass-termbuilder-ng> dec;
      debug(!"reginit4 ");
      x_matchNG := <jclass-matcher-ng> dec;
      debug(!"reginit5 ");
      e1* := <map-with-index(ds-to-interp-termbuild-access(|"children"))> kid*;
      debug(!"reginit6 ");
      e2* := <map-with-index(\ (i, _) -> e |[ children[~i:<dec; int-to-string> i] ]| \)> kid*
      ;debug(!"reginit7 ")


  
  
    