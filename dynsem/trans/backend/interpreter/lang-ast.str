module backend/interpreter/lang-ast

imports
  signatures/-
  analysis/-
  backend/interpreter/-
  backend/interpreter/terms/-
  backend/interpreter/lists/-
  backend/interpreter/tuples/-
  backend/interpreter/sorts/-
  backend/interpreter/constructors/-
  backend/utils/-
  backend/common/-
  libjava-front

rules
  
  ds-to-interp-terms-module =
    m-in-analysis(
      ?mod@Module(_, <fetch-elem(?Signatures(sig*))>);
  //    debug(!1);
      where(ds-to-interp-clean-target; ds-to-interp-gen-project);
  //    debug(!2);
      <ds-to-interp-terms-signatures-top; ds-to-interp-write-classes(|<get-opt> TermPkg())> mod;
  //    debug(!3);
      <ds-to-interp-terms-types-signatures; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg())> mod;
  //    debug(!4);
      <ds-to-inter-terms-sortbuilding; ds-to-interp-write-classes(|<get-opt> BuildPkg())> sig*;
  //    debug(!5);
      <ds-to-interp-terms-sortmatching; ds-to-interp-write-classes(|<get-opt> ChecksPkg())> sig*;
  //    debug(!6);
      <ds-to-interp-terms-building; ds-to-interp-write-classes(|<get-opt> BuildPkg())> mod;
  //    debug(!7);
      <ds-to-interp-terms-matching; ds-to-interp-write-classes(|<get-opt> MatchPkg())> mod;
  //    debug(!8);
      <ds-to-interp-nattypes-adapters-top; ds-to-interp-write-classes(|<get-opt> BuildPkg())> sig*;
      debug(!9);
      <ds-to-interp-terms-registry-top; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg())> mod;
      debug(!10);
  //    ;debug(!11);
      ds-to-interp-language; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg());
  //      debug(!12);
      ds-to-interp-language-entrypoint; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg());
  //      debug(!13);
      ds-to-interp-language-coreentry; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg());
  //      debug(!14);
      ds-to-interp-language-daemonentry; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg());
  //      debug(!15);
      ds-to-interp-language-benchmarkentry; MkSingleton; ds-to-interp-write-classes(|<get-opt> TopPkg());
  //      debug(!16);
      ds-to-interp-gen-test-harness
  //      ;debug(!17)
    )

  ds-to-interp-clean-target =
    get-opt(|CleanProject()) <
      <concat-strings> [<get-opt> JavaGenDirAbs(), "/", <string-replace(|".", "/")> <get-opt> TopPkg()];
      try(rmdir)
    + id

rules /* Sort & Constructor classes */

  ds-to-interp-terms-signatures-top:
    mod@Module(_, section*) -> [sort-class*, cons-class*, tuple-class*, list-class*]
    where
      <fetch-elem(?Signatures(sig*))> section*
    where
      sort-dec* := <fetch-elem(?Sorts(<id>))> sig*;
      cons-dec* := <fetch-elem(?Constructors(<id>))> sig*;
      list-dec* := <get-languagelist-usage-in-signatures> sig*;
      tuple-dec* := <get-languagetuple-usage-in-module> mod;
      sort-class* := <map(ds-to-interp-terms-sortdecl(|cons-dec*))> sort-dec*;
      cons-class* := <map(ds-to-interp-terms-consdecl)> cons-dec*;
      tuple-class* := <map(ds-to-interp-terms-tupledecl)> tuple-dec*;
      list-class* := <map(ds-to-interp-terms-listdecl)> list-dec*
  
  get-languagelist-usage-in-signatures:
    sig -> [explicit-list*, implicit-map-key*, implicit-map-val*]
    where
      explicit-list* := <collect-all(?ListSort(_)); nub> sig;
      implicit-map-key* := <collect-all(\ MapSort(k, _) -> ListSort(k) \); nub> sig;
      implicit-map-val* := <collect-all(\ MapSort(_, v) -> ListSort(v) \); nub> sig
  
  get-languagetuple-usage-in-module =
    ?Module(_, _);
    collect-all(?TupleSort(_));
    nub
  
  ds-to-interp-terms-sortdecl(|cons-dec*):
    dec@SortDecl(s) ->
      compilation-unit |[
        package ~x:<get-opt> TermPkg();
        
        import org.spoofax.interpreter.core.Tools;
        import org.metaborg.meta.lang.dynsem.interpreter.terms.IApplTerm;
        import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
        import org.spoofax.interpreter.terms.*;
        import com.oracle.truffle.api.CompilerAsserts;
        
        public abstract class x_class implements IApplTerm {
        
          @Override
          public Class<? extends IApplTerm> getSortClass() {
            return x_class.class;
          }
        
          @TruffleBoundary
          public static x_class create(IStrategoTerm term) {
            CompilerAsserts.neverPartOfCompilation();
            assert term != null;
            bstm0*
            bstm1
          }
          
        }
      ]|
    where
      x_class := <ds-to-interp-terms-types-name> dec;
      appl-cons-dec* := <filter(?ConsDecl(_, _, SimpleSort(s),_))> cons-dec*; 
      bstm0* := <map(ds-to-interp-terms-sortdec-createdisp)> appl-cons-dec*;
      impl-consdec* := <filter(?ConsDecl(_, [_], SimpleSort(s), Annos([ImplicitAnno()])))> cons-dec*;
      bstm1 := <foldr(! bstm |[ throw new IllegalStateException("Unsupported term: " + term); ]|, ds-to-interp-terms-sortdec-impldisp)> impl-consdec*

  ds-to-interp-terms-sortdec-createdisp:
    dec@ConsDecl(name, kid*, _, _) ->
      bstm |[
        if (Tools.isTermAppl(term) && Tools.hasConstructor((IStrategoAppl) term, ~e:Lit(String([Chars(name)])), ~i:<length; int-to-string> kid*)) {
          return ~x:<ds-to-interp-terms-types-name> dec.create(term);
        }
      ]| 

  ds-to-interp-terms-sortdec-impldisp:
    (dec@ConsDecl(name, [sref@SimpleSort(_)], _, _), bstm0) ->
      bstm |[
        try {
          return new x_class(e_create);
        } catch (IllegalStateException ~x:<newname>) {
          bstm0
        }
      ]|
    where
      x_class := <ds-to-interp-terms-types-name> dec;
      e_create := <ds-to-interp-terms-sortdec-impldisp-constr> sref 
  
  ds-to-interp-terms-sortdec-impldisp-constr:
    sref@SimpleSort(s) -> e |[ ~x:<ds-to-interp-terms-types-name> sref.create(term) ]|
    where
      <not(is-builtin-type)> s

//  ds-to-interp-terms-sortdec-impldisp-constr:
//    nt@NativeType(_, class) -> e |[ 42 ]|
//    where
//      <debug(!"TODO:")> nt 

  ds-to-interp-terms-sortdec-impldisp-constr:
    sref@SimpleSort("String") -> e |[ ((IStrategoString) term).stringValue() ]|

  ds-to-interp-terms-sortdec-impldisp-constr:
    sref@SimpleSort("Int") -> e |[ ((IStrategoInt) term).intValue() ]|


      
  ds-to-interp-hashcode-append:
    (idx, e) -> e |[ e.append(~x:$[_[idx]]) ]|
  
  
  
  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@SimpleSort(s)) ->
      e |[ x_ttype.create(e_term) ]|
    where
      <not(is-builtin-type)> s;
      x_ttype := <ds-to-interp-terms-types-name> sref

  ds-to-interp-sorts-to-create-arg:
    (e_term, ls@ListSort(_)) -> e |[ x_listclass.create(e_term) ]|
    where
      x_listclass := <ds-to-interp-terms-types-name> ls
  
  ds-to-interp-sorts-to-create-arg:
    (e_term, ts@TupleSort(_)) -> e |[ x_tupleclass.create(e_term) ]|
    where
      x_tupleclass := <ds-to-interp-terms-types-name> ts

  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    s@SimpleSort(_) -> e |[ x_elemclass.create(e_tmpelem) ]|
    where
      <not(is-builtin-type)> s;
      x_elemclass := <ds-to-interp-terms-types-name> s

  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    l@ListSort(_) -> <ds-to-interp-sorts-to-create-arg> (e_tmpelem, l)
  
  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    t@TupleSort(_) -> <ds-to-interp-sorts-to-create-arg> (e_tmpelem, t)

  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    m@MapSort(_, _) -> <ds-to-interp-sorts-to-create-arg> (e_tmpelem, m)
      
  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    SimpleSort("String") -> e |[ Tools.asJavaString(e_tmpelem) ]|

  ds-to-interp-sortelem-to-create-arg(|e_tmpelem):
    SimpleSort("Int") -> e |[ Tools.asJavaInt(e_tmpelem) ]|

  ds-to-interp-sorts-to-create-arg:
    (e_term, MapSort(skey, sval)) ->
      e |[
        new Object() {
          public com.github.krukow.clj_lang.PersistentHashMap apply() {
            IStrategoTerm x_mapT = e_term;
            assert Tools.isTermList(x_mapT);
          
            IStrategoList x_bindsT = (IStrategoList)x_mapT;
          
            java.util.Map<x_keyclass, x_valclass> x_map = new java.util.HashMap<x_keyclass, x_valclass>(
                Math.round(x_bindsT.size() / 0.75f), 0.75f);
            for (IStrategoTerm x_bindT : x_bindsT) {
              assert Tools.isTermTuple(x_bindT) && x_bindT.getSubtermCount() == 2;
              x_map.put(e_keycreate, e_valcreate);
            }
            return com.github.krukow.clj_lang.PersistentHashMap.create(x_map);
          }
        }.apply()
      ]|
    where
      x_mapT := $[_[<newname>]];
      x_bindsT := $[_[<newname>]];
      x_map := $[_[<newname>]];
      x_bindT := $[_[<newname>]];
      x_keyclass := <ds-to-interp-terms-types-name; try(ds-box-java-type)> skey;
      x_valclass := <ds-to-interp-terms-types-name; try(ds-box-java-type)> sval;
      e_keycreate := <ds-to-interp-sorts-to-create-arg> (e |[ x_bindT.getSubterm(0) ]|, skey);
      e_valcreate := <ds-to-interp-sorts-to-create-arg> (e |[ x_bindT.getSubterm(1) ]|, sval)

  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@NativeType(_, "org.spoofax.interpreter.terms.IStrategoTerm")) -> e |[ e_term ]|

  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@NativeType(_, qpath)) -> e |[ null ]|
    where
      <not(eq)> (qpath, "org.spoofax.interpreter.terms.IStrategoTerm") 

  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@SimpleSort("String")) -> e |[ ((IStrategoString) e_term).stringValue() ]|

  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@SimpleSort("Int")) -> e |[ ((IStrategoInt) e_term).intValue() ]|

  ds-to-interp-sorts-to-create-arg:
    (e_term, sref@SimpleSort("Bool")) ->
      e |[
        new Object() {
          public boolean apply() {
            IStrategoAppl x_tmp1 = (IStrategoAppl) e_term;
            assert Tools.hasConstructor(x_tmp1, "True", 0) || Tools.hasConstructor(x_tmp1, "False", 0);
            return Tools.hasConstructor(x_tmp1, "True", 0) ? true : false;
          }
        }.apply()
      ]|
    where
      x_tmp1 := $[_[<newname>]]
  
  ds-to-interp-sorts-to-create-arg:
    (e_term, SimpleSort("AST")) -> e |[ null ]|
  
  // generate equality check for a field that is of native type
  ds2java-field-eq-check:
    (idx, ty) -> 
      bstm* |[
        if (x_idx != other.x_idx) {
          return false;
        }
      ]|
    where
      <is-primitive-type> ty;
      x_idx := $[_[idx]]
  
  // generate equality check for a field that is of user type
  ds2java-field-eq-check:
      (idx, ty) -> 
      bstm* |[
        if (x_idx == null) {
          if (other.x_idx != null) {
            return false;
          }
        } else if (!x_idx.equals(other.x_idx)) {
          return false;
        }
      ]|
    where
      <not(is-primitive-type)> ty;
      x_idx := $[_[idx]]
  
  ds-to-interp-sorts-to-params = is-list; map-with-index(ds-to-interp-sort-to-param)
  
  ds-to-interp-sort-to-param:
    (i, s) -> param |[ x_sortclass x_name ]|
    where
      x_sortclass := <ds-to-interp-terms-types-name> s;
      x_name := $[_[i]]
  
  ds-to-interp-sorts-to-finits = is-list; map-with-index(ds-to-interp-sort-to-finit)
  
  ds-to-interp-sort-to-finit:
    (i, _) -> bstm |[ this.x_name = x_name; ]|
    where
      x_name := $[_[i]]

  ds-to-interp-sorts-to-fdecs = is-list; map-with-index(ds-to-interp-sort-to-fdec)
  
  ds-to-interp-sort-to-fdec:
    (i, s) -> class-body-dec |[ private final x_sortclass x_name; ]|
    where
      x_sortclass := <ds-to-interp-terms-types-name> s;
      x_name := $[_[i]]

  ds-to-interp-sorts-to-fgets = is-list; map-with-index(ds-to-interp-sort-to-fget)
  
  ds-to-interp-sort-to-fget:
    (i, s) ->
      class-body-dec |[
        public x_sortclass x_getname() {
          return x_name;
        }
      ]|
    where
      x_sortclass := <ds-to-interp-terms-types-name> s;
      x_getname := $[get_[i]];
      x_name := $[_[i]]

rules /* type system class */

  ds-to-interp-terms-types-signatures:
    mod@Module(_, section*) ->
      compilation-unit |[
        package ~x:<get-opt> TopPkg();

        import com.oracle.truffle.api.dsl.TypeSystem;
        import ~x:<get-opt> TermPkg().*;
        import ~x:<get-opt> NativePkg().*;
        import org.metaborg.meta.lang.dynsem.interpreter.terms.*;
        import com.github.krukow.clj_ds.PersistentMap;
        
        @TypeSystem({ ~type*, IApplTerm.class, ITupleTerm.class, ITerm.class, PersistentMap.class, String.class, int.class, boolean.class, Object[].class })
        public class Types {
          
        }
      ]|
    where
      <fetch-elem(?Signatures(sig-sec*))> section*;
      decl* := <filter(?Sorts(<id>) + ?Constructors(<id>) + ?NativeDataTypes(<id>)); concat;
        qsort(?(ConsDecl(_, _, _, _), SortDecl(_)) + ?(SortDecl(_), NativeBaseTypeDecl(_, _, _)) + ?(ConsDecl(_, _, _, _), NativeBaseTypeDecl(_, _, _)))> sig-sec*;
      list* := <get-languagelist-usage-in-signatures> sig-sec*;
      tuple* := <get-languagetuple-usage-in-module> mod;
      ![decl*, tuple*, list*];
      map(ds-to-interp-terms-types-name);
      map(!Lit(Class(ClassOrInterfaceType(TypeName(Id(<id>)), None())))); nub => type*

rules /* term building */

  ds-to-interp-terms-building:
    mod@Module(_, section*) -> [con-build*, list-build*, tuple-build*]
    where
      <fetch-elem(?Signatures(sig*))> section*;
      con-dec* := <fetch-elem(?Constructors(<id>))> sig*;
      list-dec* := <get-languagelist-usage-in-signatures> sig*;
      tuple-dec* := <get-languagetuple-usage-in-module> mod;
      con-build* := <map(ds-to-interp-terms-building-con)> con-dec*;
      list-build* := <map(ds-to-interp-terms-building-list)> list-dec*;
      tuple-build* := <map(ds-to-interp-terms-building-tuple)> tuple-dec*


      

rules /* term matching */

  ds-to-interp-terms-matching:
    mod@Module(_, section*) -> [con-match*, list-match*, tuple-match*]
    where
      <fetch-elem(?Signatures(sig*))> section*;
      con-dec* := <fetch-elem(?Constructors(<id>))> sig*;
      list-dec* := <get-languagelist-usage-in-signatures> sig*;
      tuple-dec* := <get-languagetuple-usage-in-module> mod;
      con-match* := <map(ds-to-interp-terms-matching-con)> con-dec*;
      list-match* := <map(ds-to-interp-terms-matching-list)> list-dec*;
      tuple-match* := <map(ds-to-interp-terms-matching-tuple)> tuple-dec*


      




