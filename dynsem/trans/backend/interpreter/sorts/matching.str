module backend/interpreter/sorts/matching

imports
  signatures/-
  signatures/dynsem/-
  backend/interpreter/-
  backend/interpreter/sorts/util
  backend/utils/-
  backend/common/-
  libjava-front

strategies

  ds-to-interp-terms-sortmatching =
    is-list;
    constr-by-sorts;
    filter((is-generatable-sortdecl, id); require(ds-to-interp-terms-sortmatching, Fst; debug-sortdecl-name|"Matching generation failed for sort"))
  
  constr-by-sorts:
    sig* -> <map(\ SortDecl(s, a) -> (SortDecl(s, a), <filter(?ConsDecl(_, _, SimpleSort(s), _))> cons-decl*) \)> sort-decl*
    where
      sort-decl* := <fetch-elem(?Sorts(<id>))> sig*;
      cons-decl* := <fetch-elem(?Constructors(<id>))> sig*
  
  ds-to-interp-terms-sortmatching:
    (dec@SortDecl(s, _), []) -> 
      compilation-unit |[
        package ~x:<get-opt> ChecksPkg();
        
        import ~x:<get-opt> TermPkg().*;
        import ~x:<get-opt> NativePkg().*;
        import com.oracle.truffle.api.dsl.NodeChild;
        import com.oracle.truffle.api.dsl.Specialization;
        import com.oracle.truffle.api.frame.VirtualFrame;
        import com.oracle.truffle.api.nodes.Node;
        import org.metaborg.meta.lang.dynsem.interpreter.nodes.building.TermBuild;
        
        @NodeChild(value = "tb", type = TermBuild.class)
        public abstract class x_issortclass extends Node {
          
          public x_issortclass() {
          }
          
          public abstract Object executeGeneric(VirtualFrame frame);
        
          public abstract x_sortclass executeEvaluated(Object term);
          
          @Specialization
          public final x_sortclass x_specialization(x_sortclass term) {
            return term;
          }
        
        }
      ]|
    where
      debug(!"srtmtc1 ");
      x_sortclass := <jclass-term> dec;
      debug(!"srtmtc2 ");
      x_issortclass := <jclass-checkedbuilder> dec;
      x_specialization := $[executeSingular[x_sortclass]]
      ;debug(!"srtmtc4 ")
  
  

  ds-to-interp-terms-sortmatching:
    (dec@SortDecl(s, _), cons-decl*@[_|_]) -> 
      compilation-unit |[
        package ~x:<get-opt> ChecksPkg();
        
        import ~x:<get-opt> TermPkg().*;
        import ~x:<get-opt> NativePkg().*;
        import org.metaborg.meta.lang.dynsem.interpreter.nodes.building.TermBuild;
        import com.oracle.truffle.api.dsl.NodeChild;
        import com.oracle.truffle.api.dsl.Specialization;
        import com.oracle.truffle.api.frame.VirtualFrame;
        import com.oracle.truffle.api.nodes.Node;
        
        @NodeChild(value = "tb", type = TermBuild.class)
        public abstract class x_issortclass extends Node {
          
          public x_issortclass() {
          }
          
          public abstract x_sortclass x_execgeneric(VirtualFrame frame);
        
          public abstract x_sortclass executeEvaluated(x_sortclass term);
          
          ~meth0*
        
        }
      ]|
    where
      debug(!"srtmtc4 ");
      x_sortclass := <jclass-term> dec;
      debug(!"srtmtc5 ");
      x_issortclass := <jclass-checkedbuilder> dec;
      debug(!"srtmtc6 ");
      x_execgeneric := $[execute[x_sortclass]];
      debug(!"srtmtc7 ");
      meth0* := <map(ds-to-interp-terms-sortmatching-con-check)> cons-decl*
      ;debug(!"srtmtc8 ")
   
    ds-to-interp-terms-sortmatching-con-check:
      dec@ConsDecl(_, _, _, _) ->
        class-body-dec |[
          @Specialization
          public final x_termclass x_method(x_termclass term) {
            return term;
          }
        ]|
      where
        debug(!"srtmtc9 ");
        x_termclass := <jclass-term> dec;
        debug(!"srtmtc10 ");
        x_method := $[execute[<shorten-uniqueify-string> x_termclass]]
        ;debug(!"srtmtc11 ")

