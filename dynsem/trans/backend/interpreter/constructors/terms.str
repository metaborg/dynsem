module backend/interpreter/constructors/terms

imports
  signatures/-
  signatures/dynsem/-
  backend/common/-
  backend/interpreter/-
  backend/interpreter/constructors/util
  backend/interpreter/terms/-

strategies

  ds-to-interp-terms-consdecls =
    is-list;
    filter(is-generatable-consdecl; require(ds-to-interp-terms-consdecl, debug-decl-name|"Term generation failed for constructor"))

rules
  
  ds-to-interp-terms-consdecl:
    dec@ConsDecl(name, kid*, s, _) ->
      compilation-unit |[
        package ~x:<get-opt> TermPkg();
        
        import org.spoofax.interpreter.core.Tools;
        import org.spoofax.interpreter.terms.*;
        import ~x:<get-opt> NativePkg().*;
//        import ~x:<get-opt> TopPkg().TypesGen;
//        import org.metaborg.meta.lang.dynsem.interpreter.nodes.matching.ITermInstanceChecker;
        import com.oracle.truffle.api.CompilerAsserts;
        import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
//        import org.apache.commons.lang3.builder.HashCodeBuilder;
//        import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
        import org.metaborg.meta.lang.dynsem.interpreter.terms.concrete.ApplTerm;
        
        public final class x_classname {

          public final static String CONSTRUCTOR = ~e:Lit(String([Chars(name)]));
          public final static int ARITY = ~i:<length; int-to-string> kid*;
          
          ~mcreate0*

          
        }
      ]|
    where
      x_classname := <jclass-term> dec;
      param0* := <ds-to-interp-sorts-to-params> kid*;
      bstm0* := <ds-to-interp-sorts-to-finits> kid*;
      fdec0* := <ds-to-interp-sorts-to-fdecs> kid*;
      fget0* := <ds-to-interp-sorts-to-fgets> kid*;
      e0* := <range; map(\ i -> e |[ ~x:<int-to-string; mkidx> ]| \)> (1, <length; inc> kid*);
      if <?SimpleSort(<id>); lookup-def(|Types()); has-prop(|ValueSort())> s
         <+ <lookup-def(|Constructors()); has-prop(|Metafunc())> (name, <length> kid*)
      then
        mcreate0* := [ class-body-dec |[
          @TruffleBoundary
          public static ApplTerm create(IStrategoTerm term) {
            throw new IllegalStateException("Value terms and metafunctions cannot be created from Stratego terms");
          }
        ]|]
      else
        e1* := <map-with-index((\ i -> e |[ term.getSubterm(~i:<dec; int-to-string>) ]| \, id); ds-to-interp-sorts-to-create-arg)> kid*;
        sort-string := <string-type> s; 
        mcreate0* := [ class-body-dec |[
          @TruffleBoundary
          public static ApplTerm create(IStrategoTerm term) {
            CompilerAsserts.neverPartOfCompilation();
            assert term != null;
            assert Tools.isTermAppl(term);
            assert Tools.hasConstructor((IStrategoAppl) term, CONSTRUCTOR, ARITY);
            return new ApplTerm(~e:Lit(String([Chars(sort-string)])).intern(), CONSTRUCTOR.intern(), new Object[] { e1* }, (CONSTRUCTOR + "/" + ARITY).intern(), term);
          } ]| ]
      end;
      e_hash := <foldr(!e |[ new HashCodeBuilder() ]|, ds-to-interp-hashcode-append)> <range> (1, <length; inc> kid*);
      bstm3* := <map-with-index(Fst; !bstm |[ sb.append(~x:<int-to-string; mkidx>); ]|); separate-by(|bstm |[ sb.append(", "); ]|)> kid*
    where
      if [] := kid*
      then
        finit* := class-body-dec* |[
          public final static x_classname SINGLETON = new x_classname();
          private x_classname() {
            this(null);
          }
          
          private x_classname(IStrategoTerm strategoTerm){
            this.strategoTerm = strategoTerm;
          }
        ]|;
        mequals0* := class-body-dec* |[
          @Override
          public boolean equals(Object obj) {
            return (this == obj);
          }
        ]|
      else
        finit* := class-body-dec* |[
          public x_classname(param0*) {
            this(e0*, null);
          }
          
          private x_classname(param0*, IStrategoTerm strategoTerm) {
            bstm0*
            this.strategoTerm = strategoTerm;
          }
        ]|;
        bstm2* := <map-with-index(ds2java-field-eq-check)> kid*;
        mequals0* := class-body-dec* |[
          @Override
          public boolean equals(Object obj) {
            if (this == obj)
              return true;
            if (obj == null)
              return false;
            if (getClass() != obj.getClass())
              return false;
            x_classname other = (x_classname) obj;
            bstm2*
            return true;
          }
        ]|
      end

